// Đọc thêm dữ liệu từ socket, ghi tiếp vào cuối recv_buf
        
        if (bytes < 0)
        {
            perror("recv() error");
            break;
        }
        else if (bytes == 0)
        {
            printf("Connection closed: %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
            break;
        }


// Cập nhật tổng số byte đang có trong buffer


        recv_len += bytes;
        recv_buf[recv_len] = '\0';  // thêm ký tự kết thúc chuỗi

        // start: con trỏ bắt đầu của dòng hiện tại
        char *start = recv_buf;
        char *end;

        // Tìm trong recv_buf xem có cặp ký tự "\r\n" không
        while ((end = ) != NULL)
        {
            // Tính độ dài dòng (từ start đến trước \r\n)
            size_t line_size = end - start;

            // Nếu dòng quá dài, cắt bớt để tránh tràn bộ nhớ
            if (line_size >= sizeof(line_buf))
                line_size = sizeof(line_buf) - 1;

            // Sao chép phần dòng đó vào line_buf
            memcpy(line_buf, start, line_size);
            line_buf[line_size] = '\0';

            // Xử lý dòng lệnh hoàn chỉnh
            handle_client_request(line_buf, line_size);

            // Di chuyển start đến sau "\r\n" để tiếp tục tìm dòng kế tiếp
            start = end + 2; // bỏ qua "\r\n"
        }

        // Sau khi xử lý xong, có thể còn lại dữ liệu chưa đủ để thành 1 dòng hoàn chỉnh
        // (ví dụ client mới gửi "UPLD 1GB.b" chưa có \r\n)
        // Ta sẽ giữ phần dư lại đầu buffer cho lần recv() sau
        recv_len = strlen(start);
        memmove(recv_buf, start, recv_len);
